// Generated by CoffeeScript 1.8.0
(function() {
  var Nav, Pin, Util, container, spinner;

  Util = {
    id: function(id) {
      return document.getElementById(id);
    },
    element: function(tagName, attrs) {
      var el, k, v;
      el = document.createElement(tagName);
      for (k in attrs) {
        v = attrs[k];
        el.setAttribute(k, v);
      }
      el.inject = function(parent) {
        return parent.appendChild(el);
      };
      return el;
    },
    postForm: function(path, data, success, error) {
      var k, params, req, v;
      params = [];
      for (k in data) {
        v = data[k];
        params.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
      }
      req = new XMLHttpRequest();
      req.onload = success;
      req.onerror = error;
      req.open('post', path);
      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      return req.send(params.join('&'));
    },
    csrfToken: function() {
      return Util.id('csrf-token').getAttribute('value');
    },
    myFingerprint: function() {
      return Util.id('my-fingerprint').getAttribute('value');
    },
    signinToken: function() {
      var token;
      token = Util.id('signin-token').getAttribute('value');
      if (token === '') {
        return null;
      } else {
        return token;
      }
    }
  };

  Nav = {
    init: function() {
      var el, _i, _len, _ref;
      Util.id('signout-link').addEventListener('click', Nav.signOut);
      Util.id('delete-link').addEventListener('click', Nav.deleteAccount);
      if (Util.signinToken() != null) {
        window.addEventListener('popstate', Nav.updateVisiblePage);
      }
      _ref = document.getElementsByClassName('sp-link');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        el = _ref[_i];
        el.addEventListener('click', Nav.navigateSubPage);
      }
      if (Util.signinToken() != null) {
        return Nav.listenForSignin(Util.signinToken());
      }
    },
    updateVisiblePage: function() {
      var el, page, _i, _len, _ref;
      _ref = Util.id('explain').childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        el = _ref[_i];
        el.hidden = true;
      }
      page = location.pathname.match(/\/(.*)/)[1];
      if (page === '') {
        page = 'intro';
      }
      return Util.id(page).hidden = false;
    },
    navigateSubPage: function(e) {
      var href;
      e.preventDefault();
      href = e.target.href || e.target.parentNode.href;
      history.pushState(null, null, href);
      return Nav.updateVisiblePage();
    },
    listenForSignin: function(token) {
      var source;
      source = new EventSource('signin/' + token + '/notify');
      return source.addEventListener('authenticated', function() {
        var form;
        form = Util.element('form', {
          action: 'signin/' + token,
          method: 'post'
        }).inject(document.body);
        Util.element('input', {
          type: 'hidden',
          name: 'csrf_token',
          value: Util.csrfToken()
        }).inject(form);
        return form.submit();
      });
    },
    signOut: function() {
      var form;
      form = Util.element('form', {
        action: 'signout',
        method: 'post'
      }).inject(document.body);
      Util.element('input', {
        type: 'hidden',
        name: 'csrf_token',
        value: Util.csrfToken()
      }).inject(form);
      return form.submit();
    },
    deleteAccount: function() {
      var form;
      form = Util.element('form', {
        action: 'delete-account',
        method: 'post'
      }).inject(document.body);
      Util.element('input', {
        type: 'hidden',
        name: 'csrf_token',
        value: Util.csrfToken()
      }).inject(form);
      return form.submit();
    }
  };

  Pin = {
    init: function(globe) {
      var pin;
      pin = {
        well: Util.id('pinwell'),
        drag: Util.id('pindrag'),
        globe: globe,
        offset: new THREE.Vector2(0, 0)
      };
      Pin.addEvents(pin);
      return pin;
    },
    eventModes: {
      rest: [['well', 'mouseenter', 'wellEnter'], ['well', 'mouseleave', 'wellLeave'], ['well', 'mousedown', 'wellDown']],
      wellPressed: [['well', 'mousemove', 'wellPull'], ['well', 'mouseleave', 'dragStart'], ['well', 'mouseup', 'wellUp']],
      dragVoid: [['document', 'mousemove', 'dragMove'], ['document', 'mouseup', 'dragReset']],
      dragGlobe: [['document', 'mousemove', 'globeMove'], ['document', 'mouseup', 'globeUp']]
    },
    addEvents: function(pin) {
      pin.events = {
        wellEnter: function() {
          return pin.well.classList.add('hover');
        },
        wellLeave: function() {
          return pin.well.classList.remove('hover');
        },
        wellDown: function(e) {
          pin.well.style.cursor = 'grabbing';
          pin.offset = Pin.wellOffset(pin.well, e);
          return Pin.transitionMode(pin, 'wellPressed');
        },
        wellUp: function() {
          pin.well.style.cursor = null;
          return Pin.transitionMode(pin, 'rest');
        },
        wellPull: function(e) {
          var dist;
          dist = pin.offset.distanceTo(Pin.wellOffset(pin.well, e));
          if (dist > 10) {
            return pin.events.dragStart(e);
          }
        },
        dragStart: function(e) {
          var fingerprint, gl, glpin;
          pin.events.wellLeave();
          pin.events.wellUp();
          pin.well.classList.add('empty');
          pin.events.dragMove(e);
          pin.drag.hidden = false;
          pin.drag.style.transformOrigin = pin.offset.x + 'px ' + pin.offset.y + 'px';
          fingerprint = Util.myFingerprint();
          gl = pin.globe.gl;
          glpin = gl.pins.fingerprints[fingerprint];
          if (glpin != null) {
            gl.pins.fingerprints[fingerprint] = null;
            gl.pins.remove(glpin);
          }
          return Pin.transitionMode(pin, 'dragVoid');
        },
        dragMove: function(e) {
          var dist, easing, globeOffset, pos, scale;
          pin.drag.style.left = (e.clientX - pin.offset.x) + 'px';
          pin.drag.style.top = (e.clientY - pin.offset.y) + 'px';
          globeOffset = Pin.globeOffset(pin.globe.container, e);
          dist = Globe.glMouse(globeOffset).length();
          easing = function(x) {
            return x * x;
          };
          scale = Pin.interpolate([1.54, 0.87], [1, 0.1], easing, dist);
          Pin.scalePin(pin.drag, scale);
          pos = Globe.raycast(pin.globe.gl, Pin.nudgeUpwards(globeOffset));
          if (pos != null) {
            return pin.events.globeEnter(e);
          }
        },
        dragReset: function() {
          pin.well.classList.remove('empty');
          pin.drag.hidden = true;
          Util.postForm('pin', {
            csrf_token: Util.csrfToken()
          });
          return Pin.transitionMode(pin, 'rest');
        },
        globeEnter: function(e) {
          pin.drag.hidden = true;
          pin.globe.interaction.dragPin = Globe.makePin(pin.globe.gl, true);
          pin.globe.gl.scene.add(pin.globe.interaction.dragPin);
          pin.events.globeMove(e);
          Globe.setCaption();
          Globe.transitionMode(pin.globe, 'hoveringWithPin');
          return Pin.transitionMode(pin, 'dragGlobe');
        },
        globeMove: function(e) {
          var globeOffset, pos;
          globeOffset = Pin.globeOffset(pin.globe.container, e);
          pos = Globe.raycast(pin.globe.gl, Pin.nudgeUpwards(globeOffset));
          if (pos != null) {
            Globe.positionPin(pin.globe.gl, pin.globe.interaction.dragPin, pos);
          }
          if (pos == null) {
            return pin.events.globeLeave(e);
          }
        },
        globeLeave: function(e) {
          pin.globe.gl.scene.remove(pin.globe.interaction.dragPin);
          pin.globe.interaction.dragPin = null;
          pin.events.dragMove(e);
          pin.drag.hidden = false;
          Globe.transitionMode(pin.globe, 'rest');
          return Pin.transitionMode(pin, 'dragVoid');
        },
        globeUp: function(e) {
          var gl, globeOffset, glpin, latLon, pos;
          gl = pin.globe.gl;
          gl.scene.remove(pin.globe.interaction.dragPin);
          pin.globe.interaction.dragPin = null;
          pin.drag.hidden = true;
          globeOffset = Pin.globeOffset(pin.globe.container, e);
          pos = Globe.raycast(gl, Pin.nudgeUpwards(globeOffset));
          if (pos != null) {
            glpin = Globe.makePin(gl, true);
            glpin.fingerprint = Util.myFingerprint();
            Globe.positionPin(gl, glpin, pos);
            gl.pins.fingerprints[glpin.fingerprint] = glpin;
            gl.pins.add(glpin);
            latLon = Globe.vectorToLatLon(pos);
            Util.postForm('pin', {
              csrf_token: Util.csrfToken(),
              lat: latLon.lat,
              lon: latLon.lon
            });
          }
          Globe.transitionMode(pin.globe, 'rest');
          return Pin.transitionMode(pin, 'rest');
        }
      };
      return Pin.transitionMode(pin, 'rest');
    },
    transitionMode: function(pin, mode) {
      var binding, targets, _i, _j, _len, _len1, _ref, _ref1;
      targets = {
        well: pin.well,
        document: document
      };
      if (pin.mode != null) {
        _ref = Pin.eventModes[pin.mode];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          binding = _ref[_i];
          targets[binding[0]].removeEventListener(binding[1], pin.events[binding[2]]);
        }
      }
      _ref1 = Pin.eventModes[mode];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        binding = _ref1[_j];
        targets[binding[0]].addEventListener(binding[1], pin.events[binding[2]]);
      }
      return pin.mode = mode;
    },
    scalePin: function(pin, scale) {
      pin.style.transform = 'scale(' + scale + ',' + scale + ')';
      return pin.getElementsByClassName('outline')[0].style.strokeWidth = 2 / scale;
    },
    elementPosition: function(el) {
      return new THREE.Vector2(el.offsetLeft, el.offsetTop);
    },
    mouse: function(e) {
      return new THREE.Vector2(e.clientX, e.clientY);
    },
    wellOffset: function(well, e) {
      return Pin.mouse(e).sub(Pin.elementPosition(well.parentNode));
    },
    globeOffset: function(globeContainer, e) {
      return Pin.mouse(e).sub(Pin.elementPosition(globeContainer));
    },
    nudgeUpwards: function(pos) {
      return pos.clone().add(new THREE.Vector2(0, -8));
    },
    clamp: function(limits, x) {
      if (limits[1] < limits[0]) {
        limits = [limits[1], limits[0]];
      }
      if (x < limits[0]) {
        return limits[0];
      } else if (x > limits[1]) {
        return limits[1];
      } else {
        return x;
      }
    },
    interpolate: function(domain, range, easing, x) {
      var s;
      x = Pin.clamp(domain, x);
      s = (x - domain[0]) / (domain[1] - domain[0]);
      if (easing != null) {
        s = easing(s);
      }
      return s * (range[1] - range[0]) + range[0];
    }
  };

  if (Detector.webgl) {
    spinner = Util.id('spinner-container');
    spinner.style.display = null;
    Globe.loadEverything(function(textures, xhr) {
      var globe, pin;
      spinner.parentNode.removeChild(spinner);
      globe = Globe.init(Util.id('gl'), textures, xhr);
      globe.container.style.display = null;
      return pin = Pin.init(globe);
    });
  } else {
    container = Util.id('gl');
    container.style.display = null;
    Util.element('img', {
      src: 'images/nogl.jpg',
      alt: "WebGL is missing"
    }).inject(container);
  }

  Nav.init();

}).call(this);
